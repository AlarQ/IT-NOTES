Value in parameters will be called first 
<pre>
	<code>def byValueFunction(x: Int) = x + 12
	byValueFunction(2 + 3)</code>
</pre>
2 + 3 is passed LITERALLY, evaluated, when used first
<pre>
	<code>def byNameFunction(x: => Int) = x + 12 
	byNameFunction(2 + 3)</code>
</pre>
# Trick 1 - reevaluation

Example: print system time
<pre>
	<code>def byValuePrint(x: Long) = {
		println(x)
		println(x)
	  }

	  def byNamePrint(x: => Long) = {
		println(x)
		println(x)
	  }

	  def main(args: Array[String]): Unit = {
		// Two times the same value: called by value
		byValuePrint(System.nanoTime())
		// Different values: called by name
		byNamePrint(System.nanoTime())
	  }</code>
</pre>
# Trick 2 - called by need - powerful in infinite collections, used in LazyList
<pre>
	<code>abstract class MyList[+T] {
		def head: T

		def tail: MyList[T]
	  }

	  class NonEmptyList[+T](h: => T, t: => MyList[T]) extends MyList[T] {
		override lazy val head: T = h
		override lazy val tail: MyList[T] = t
	  }</code>
</pre>
# Trick 3 - hold the door
Try.apply must have byName parameters, cause of exceptions
<pre>
	<code>val anAttempt: Try[Int] = Try {
		throw new NullPointerException
	  }

	  val aFuture = Future {
		42
	  }</code>
</pre>