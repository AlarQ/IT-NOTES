<ul>
	<li>Akka Streams is used to create some potentially asynchronous components that deal with receiving and/or passing data around your application. Let's create a stream example.
		<pre><code>implicit val system = ActorSystem()

  // a source - emits elements
  val source = Source(1 to 1000)

  // a flow - receives elements, transforms them and emits their result
  val flow = Flow[Int].map(_ * 3)

  // a sink - receiver of elements
  val sink = Sink.foreach[Int](println)
  
  val graph = source.via(flow).to(sink)</code></pre>
  The graph is not active yet.
	</li>	
	<li>Starting graph
		<pre><code>graph.run()</code></pre>
	</li>
	<li>Graph DSL is next level of akka streams. Ibntroducing TASK: 
		source of ints -> 2 independend "hard" computations -> concat in tuple -> print the tuple
		<pre><code>  // Step #1 - the frame
  val specialGraph = GraphDSL.create(){
    implicit builder: GraphDSL.Builder[NotUsed] =>
      import GraphDSL.Implicits._

      // Step #2 - create the building blocks
      val input = builder.add(Source(1 to 1000))
      val incrementer = builder.add(Flow[Int].map(_ + 1))
      val multiplier = builder.add(Flow[Int].map(_ * 10))
      val output = builder.add(Sink.foreach[(Int,Int)](println))

      val broadcast = builder.add(Broadcast[2](2))
      val zip = builder.add(Zip[Int,Int])

      // Step #3 - glue components together
      // input FEEDS INTO broadcast
      input ~> broadcast

      broadcast.out(0) ~> incrementer ~> zip.in0
      broadcast.out(1) ~> multiplier ~> zip.in1

      zip.out ~> output

      // Step #4 - closing
      // marker to validate graph
      ClosedShape
  }

  RunnableGraph.fromGraph(specialGraph).run()</code></pre>
	</li>
</ul>