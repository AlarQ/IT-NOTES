<ul>
	<li>Let's define two hierarchies
		<pre><code>object SelfType {

  trait Edible

  // hierarchy #1
  trait Person {
    def hasAllergiesTo(thing: Edible): Boolean
  }

  trait Child extends Person

  trait Adult extends Person

  // hierarchy #2
  trait Diet{ self: Person =>
    def canEat(thing: Edible): Boolean = self.hasAllergiesTo(thing)
  }

  trait Carnivore extends Diet with Person
  class VegetarianAthlete extends Diet with Adult{
    override def hasAllergiesTo(thing: Edible): Boolean = false
  }
}</code></pre>
	</li>We want to solve PROBLEM: Diet must be applicable to Persons only - if you create a concrete class and mix-in Diet or one of its children, you have to also mix-in Person on one of its children.
	<li>This issue comes up often when you design library API. You often come accros two different class hierarchies, which have to interact with each other, but don't have clear relationship with each other. However their logic depends on one another 
	</li>
	<li>Oprion #1 - enforce suptype relationship: Diet extends Person,
	then Diet methods can have access to Person elements
	but it make any sense
	</li>
	<li>Option #2 - add type argument
		<pre><code>trait Diet[T <: Person]{
      def canEat(thing: Edible) : Boolean
    }

    trait Carnivore[T<: Person] extends Diet[T]
    trait Vegetarian[T <: Person] extends Diet[T]</code></pre>
	</li>
	<li>Option #3 = selfType
	adding selfType to Diet means:
	whoever extends Diet must also extend (or mix-in) Person. Whe can you this as self.
		<pre><code>trait Diet{ self: Person =>
    def canEat(thing: Edible): Boolean = self.hasAllergiesTo(thing)
  }</code></pre>
	</li>
</ul>