<ul>
   <li>
      Monads are types that deals with two things:
      <ol>
   <li>ability to wrap a value into value of another type, named pure or unit</li>
   <li>ability to transform a wrap of one type value to wrap of another type value, named bind or flatMap</li>
   </ol>
   </li>
   <li>
      Example #1
      <pre><code>case class SafeValue[+T](private val internalValue: T) { // constructor - pure or unit
    def get = synchronized {
      // placeholder for something interesting
      internalValue
    }

	// bind or flatMap
    def flatMap[S](transformer: T => SafeValue[S]): SafeValue[S] = synchronized {
      transformer(internalValue)
    }
  }</code></pre>
   </li>
   <li>
      Example #2 - census, Option
      <pre><code>case class Person(firstName: String, lastName: String) {
    assert(firstName != null && lastName != null)
  }

  // census API
  // weak way, when we have many arguments
  def getPerson(firstName: String, lastName: String): Person =
    if (firstName != null) {
      if (lastName != null) {
        Person(firstName, lastName)
      } else {
        null
      }
    } else {
      null
    }

  // better way
  def getPersonBetter(firstName: String, lastName: String): Option[Person] =
    Option(firstName).flatMap(fName =>
      Option(lastName).flatMap(lName =>
        Option(Person(fName, lName))
      ))

  // even better way, much more east to read, converted to flatMap.
  def getPersonEvenBetter(firstName: String, lastName: String): Option[Person] = for {
    fName <- Option(firstName)
    lName <- Option(lastName)
  } yield Person(fName, lName)</code></pre>
   </li>
   <li>
      Example #3 - asynchronous fetches
      <pre><code>  // online store
  case class User(id: String)

  case class Product(sku: String, price: BigDecimal)

  // external APIs

  def getUser(url: String): Future[User] = Future {
    User("Adam") // sample impl
  }

  def getLastOrder(userId: String): Future[Product] = {
    Future(Product("123-456", 12.12)) // sample impl
  }
  // TASK: get last Adam's product
  val adamsUrl = "my.store.com/users/adam"
  // ETW - beginner's way, very bad
  getUser(adamsUrl).onComplete {
    case Success(User(id)) =>
      val lastOrder = getLastOrder(id)
      lastOrder.onComplete {
        case Success(Product(sku, p)) =>
          val vatIncludedPrice = p * 1.23
        // pass it on - send Adam on email
      }
  }

  // much better 
  val vatIncludedPrice: Future[BigDecimal] = getUser(adamsUrl)
    .flatMap(user => getLastOrder(user.id))
    .map(_.price * 1.23)

  // even better
  val vatIncludedPriceFor = for {
    user <- getUser(adamsUrl)
    product <- getLastOrder(user.id)
  } yield product.price * 1.23</code></pre>
   </li>
   <li>
      // Example #4: double for-loops
      <pre><code>val numbers = List(1, 2, 3)
  val chars = List('a', 'b', 'c')

  // flatMaps
  val checkerBoard = numbers.flatMap(number => chars.map(char => (number, char)))

  val checkerBoardFor = for {
    number <- numbers
    char <- chars
  } yield (number, char)</code></pre>
   </li>
   <li>
      Monads properties
      <ol>
         <li>
            Prop #1 - Left Identity: Monad(x).flatMap(f) == f(x)
            <pre><code>def twoConsecutive(x: Int) = List(x, x + 1)

  twoConsecutive(3) // List(3,4)
  List(3).flatMap(twoConsecutive) // List(3,4)</code></pre>
         </li>
         <li>
            Prop #2 - Right Identity: Monad(x).flatMap(x => Monad(x)) = Monad(x) // USELESS
            <pre><code>List(1, 2, 3).flatMap(x => List(x)) // List(1,2,3)</code></pre>
         </li>
         <li>
            Prop #3 - associativity, implementing ETW over and over:Monad(x).flatMap(f).flatMap(g) == Monad(x).flatMap(x => f(x).flatMap(g))
            <pre><code>val numbers = List(1,2,3)
			val incrementer = (x: Int) => List(x, x + 1)
  val doubler = (x: Int) => List(x, 2 * x)
  numbers.flatMap(incrementer).flatMap(doubler) // List(1, 2, 2, 4 generated by 1
                                                  //  2, 4, 3, 6 generated by 2
											//  3, 6, 4, 8 generated by 3)
  // List(1, 2, 2, 4, 2, 4, 3, 6, 3, 6, 4, 8) equals:
    /*
    List(
    incrementer(1).flatMap(doubler),
    incrementer(2).flatMap(doubler),
    incrementer(3).flatMap(doubler)
    )
     */
  // the same result:
  numbers.flatMap(x => incrementer(x).flatMap(doubler))</code></pre>
         </li>
      </ol>
   </li>
</ul>